require './util'

# Implement a first order markov model
# Subclasses below reimplement methods to define higher orders
class MarkovModel
    attr_reader :count
    
    def initialize()
        @dataFreq = {}
        @count = 0
    end
    
    # add an item
    # Base class implements a Unigram model, so we'll ignore any prev arguments
    def addItem(item, *prev)
        if @dataFreq.has_key?(item)
            @dataFreq[item] += 1
        else
            @dataFreq[item] = 1
            @count += 1
        end
    end
    
    # pick a random item from the top <numItemsToPickFrom> items in the frequency hash
    # larger number will increase the variety generated by the model
    # Base class implements a Unigram model, so we'll ignore any prev arguments
    def getRandomItem(numItemsToPickFrom, *prev)
        items = Util.getItemsWithMaxFreq(numItemsToPickFrom, @dataFreq)
        return Util.randomItem(items)
    end
    
    def printStats(file, name="First order markov model")
        out = File.new(file, "w")
        @dataFreq.each_key do |word1|
            out.puts("#{word1}, #{@dataFreq[word1]}")
        end
        out.close
        puts "#{name} has #{@count} entries, saved to #{file}"
    end
end

class SecondOrderMarkovModel < MarkovModel
    # addItem(item, prev1)
    def addItem(item, *prev)
        prev1 = prev[0]
        raise "undefined or empty prev1 argument!" if prev1.nil? or prev1 == ""
            
        if @dataFreq.has_key?(prev1)
            if @dataFreq[prev1].has_key?(item)
                @dataFreq[prev1][item] += 1
            else
                @dataFreq[prev1][item] = 1
                @count += 1
            end
        else
            @dataFreq[prev1] = {}
            @dataFreq[prev1][item] = 1
            @count += 1
        end
    end

    # returns nil if the previous item was not in the frequency hash, otherwise returns an item
    # which is likely to follow the previous one
    def getRandomItem(numItemsToPickFrom, *prev)
        prev1 = prev[0]
        raise "undefined or empty prev1 argument!" if prev1.nil? or prev1 == ""
        
        if @dataFreq.has_key?(prev1)
            items = Util.getItemsWithMaxFreq(numItemsToPickFrom, @dataFreq[prev1])
            return Util.randomItem(items)
        else
            return nil
        end
    end
    
    def printStats(file, name="Second order markov model")
        out = File.new(file, "w")
        @dataFreq.each_key do |word1|
            @dataFreq[word1].each_key do |word2|
                out.puts("#{word1} #{word2}, #{@dataFreq[word1][word2]}")
            end
        end
        out.close
        puts "#{name} has #{@count} entries, saved to #{file}"
    end
end

class ThirdOrderMarkovModel < MarkovModel
    # addItem(item, prev1, prev2)
    def addItem(item, *prev)
        prev1 = prev[0]
        prev2 = prev[1]
        raise "undefined or empty prev1 argument!" if prev1.nil? or prev1 == ""
        raise "undefined or empty prev2 argument!" if prev2.nil? or prev2 == ""
                    
        if @dataFreq.has_key?(prev2)
            if @dataFreq[prev2].has_key?(prev1)
                if @dataFreq[prev2][prev1].has_key?(item)
                    @dataFreq[prev2][prev1][item] += 1
                else
                    @dataFreq[prev2][prev1][item] = 1
                    @count += 1
                end
            else
                @dataFreq[prev2][prev1] = {}
                @dataFreq[prev2][prev1][item] = 1
                @count += 1
            end
        else
            @dataFreq[prev2] = {}
            @dataFreq[prev2][prev1] = {}
            @dataFreq[prev2][prev1][item] = 1
            @count += 1
        end
    end

    # returns nil if the previous item was not in the frequency hash, otherwise returns an item
    # which is likely to follow the previous one
    def getRandomItem(numItemsToPickFrom, *prev)
        prev1 = prev[0]
        prev2 = prev[1]
        raise "undefined or empty prev1 argument!" if prev1.nil? or prev1 == ""
        raise "undefined or empty prev2 argument!" if prev2.nil? or prev2 == ""
        
        if @dataFreq.has_key?(prev2)
            if @dataFreq[prev2].has_key?(prev1)
                items = Util.getItemsWithMaxFreq(numItemsToPickFrom, @dataFreq[prev2][prev1])
                return Util.randomItem(items)
            else
                return nil
            end
        else
            return nil
        end
    end

    def printStats(file, name="Third order markov model")
        out = File.new(file, "w")
        @dataFreq.each_key do |word1|
            @dataFreq[word1].each_key do |word2|
                @dataFreq[word1][word2].each_key do |word3|
                    out.puts("#{word1} #{word2} #{word3}, #{@dataFreq[word1][word2][word3]}")
                end
            end
        end
        out.close
        puts "#{name} has #{@count} entries, saved to #{file}"
    end
end